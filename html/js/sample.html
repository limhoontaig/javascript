<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    class Students {
      constructor (name, koreanScore, englishScore) {
        this.name = name; 
        this.koreanScore = koreanScore; 
        this.englishScore = englishScore; 
      } 
      
      sum () { 
        return (this.koreanScore + this.englishScore); 
      } 
      info () { 
        return `name: ${this.name}, total: ${this.sum()}`;
      }
    } 
    const stu001 = new Students('mina', 100, 70); 
    const stu002 = new Students('lily', 90, 60); 
    console.log(stu001); // Students { name: 'mina', koreanScore: 100, englishScore: 70 } 
    console.log(stu002); // Students { name: 'lily', koreanScore: 90, englishScore: 60 } 
    console.log(stu001.sum()); // 170 
    console.log(stu002.sum()); // 150 
    console.log(stu001.info()); // name: mina, total: 170 
    console.log(stu002.info()); // name: lily, total: 150 // stu002.sum 변경 
    stu002.sum = function () { 
      return (this.koreanScore + this.englishScore + 10); 
    } 
    console.log(stu002.info()); // name: lily, total: 160

  </script>
  <script>
    class ExtentionStudents extends Students { 
      constructor (name, koreanScore, englishScore, mathScore) { 
        super(name, koreanScore, englishScore); 
        this.mathScore = mathScore; 
      } 
      total () { 
        return (super.sum() + this.mathScore); 
      } 
    } 
    const stu004 = new ExtentionStudents('rose', 100, 80, 60); 
    console.log(stu004); // { name: 'rose', koreanScore: 100, englishScore: 80, mathScore: 60 } 
    console.log(stu004.total()); // 240

    // map function example
    // 자바스크립트의 map함수는 callback함수 실행한 결과 반환값으로 배열의 길이, 순서를 유지한 새로운 배열을 만듭니다.
    // arr.map(callback(currentValue[, index[, array]])[, thisArg])
    
    // example 1. 배열 속 숫자의 제곱을 구한 새로운 숫자배열 만들기
    
    const numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; // 기존 배열
    // map1 - callback함수를 직접 작성
    const map1 = numbers.map(currentNumber => currentNumber * currentNumber);
    console.log('map1 =', map1);

    // map2 - callback함수 선언 후 이용
    function calcDouble(currentNumber) {
      // Math.pow(x, y) - x의 y 제곱을 반환합니다.
      return Math.pow(currentNumber, 2);
    }
    const map2 = numbers.map(calcDouble);
    console.log('map2 =', map2);

    //2. 숫자배열로 숫자값과 인덱스를 갖는 오브젝트 배열 만들기
    const numbersIndex = [1, 3, 5, 7, 9];
    const objectArr = numbersIndex.map((number, index) => ({ number, index }));
    console.log('objectArr =', objectArr);
    
    //3. 오브젝트 배열을 이용하여 새로운 오브젝트 배열 만들기
    // 실제직업과 다릅니다.
    const friends = [
      {
        name: '양주진',
        age: 55,
        job: '코인러'
      },
      {
        name: '오영제',
        age: 42,
        job: '랩퍼'
      },
      {
        name: '서준형',
        age: 32,
        job: '2년차 유부남'
      }
    ];

    // 10년 후의 모습을 예상합니다.
    const tenYearsLaterFriends = friends.map((friend) => {
      // 나이는 10살씩 더 먹겠네요
      const returnObj = friend;
      returnObj.age += 10;
      
      // 새로운 직업을 갖고 있을 듯 합니다.
      let newJob;
      switch(returnObj.job) {
        case '코인러':
          newJob = '한강뷰 또는 한강속';
          break;
        case '2년차 유부남':
          newJob = '12년차 유부남';
          break;
        default:
          newJob = '무직';
          break;
      }
      returnObj.job = newJob;
      return returnObj;
    })

    console.log('10년 후 친구들.. ', tenYearsLaterFriends);

  </script>

</body>
</html>